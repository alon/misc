#!/usr/bin/python

"""
Small silly dns server that caches to /etc/hosts file

why?

Here's why:

[a@b bin]# ping www.google.com
PING www.l.google.com (209.85.227.103) 56(84) bytes of data.
64 bytes from www.google.com. (209.85.227.103): icmp_seq=1 ttl=46 time=101 ms
64 bytes from www.google.com. (209.85.227.103): icmp_seq=2 ttl=46 time=103 ms
^C
--- www.l.google.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1357ms
rtt min/avg/max/mdev = 101.313/102.412/103.511/1.099 ms
[a@b bin]# wget www.google.com
--2010-03-15 17:35:47--  http://www.google.com/
Resolving www.google.com... failed: No address associated with hostname.
wget: unable to resolve host address "www.google.com"

"""

import socket
import os
import stat
import linecache
import time


class DNSQuery:
  """ Straight from http://code.activestate.com/recipes/491264-mini-fake-dns-server/
  (names changed to english)
  """
  def __init__(self, data):
    self.data=data
    self.domain=''

    tipo = (ord(data[2]) >> 3) & 15   # Opcode bits
    if tipo == 0:                     # Standard query
      ini=12
      lon=ord(data[ini])
      while lon != 0:
        self.domain+=data[ini+1:ini+lon+1]+'.'
        ini+=lon+1
        lon=ord(data[ini])

  def response(self, ip):
    packet=''
    if self.domain:
      packet+=self.data[:2] + "\x81\x80"
      packet+=self.data[4:6] + self.data[4:6] + '\x00\x00\x00\x00'   # Questions and Answers Counts
      packet+=self.data[12:]                                         # Original Domain Name Question
      packet+='\xc0\x0c'                                             # Pointer to domain name
      packet+='\x00\x01\x00\x01\x00\x00\x00\x3c\x00\x04'             # Response type, ttl and resource data length -> 4 bytes
      packet+=str.join('',map(lambda x: chr(int(x)), ip.split('.'))) # 4bytes of IP
    return packet

def filedate(x):
    return os.stat(x)[stat.ST_CTIME]

def updated(x):
    return x not in cache or cache[x][0] < filedate(x)

class IPCache(object):

    _hosts_filename = '/etc/hosts'

    def __init__(self):
        self._readdb()

    def _readdb(self):
        self._lines = linecache.getlines(self._hosts_filename)
        tokens = [x.strip().split() for x in self._lines if x.strip()[:1] != '#' and x.strip() != '']
        self._db = {}
        for line in tokens:
            ip, hosts = line[0], line[1:]
            for host in hosts:
                self._db[host] = ip

    def _write_db(self):
        header="""
#autogenerated by mydns
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 dhcp-1-173.tlv.redhat.com
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6 dhcp-1-173.tlv.redhat.com
"""
        fd = open('/etc/hosts','w+')
        fd.write(header)
        for hostname, ip in self._db.items():
            if 'localhost' in hostname: continue
            hosts = [hostname]
            if hostname[-1:] == '.' and len(hostname) > 1:
                hosts.append(hostname[:-1])
            fd.write('%s\t%s\n' % (ip, '\t'.join(hosts)))
        fd.close()

    def call_dig(self, hostname):
        lines = os.popen('dig @10.35.255.6 %s' % hostname).readlines()
        sections = [i for i, line in enumerate(lines) if line.find('SECTION') != -1]
        answer_sections = [i for i in xrange(len(sections)) if lines[sections[i]].find('ANSWER') != -1]
        if len(answer_sections) == 0: return False
        answer_section = answer_sections[0]
        answer = [x.strip() for x in lines[sections[answer_section]+1:sections[answer_section+1]] if x.strip() != '' and x.find('A\t')!=-1]
        if len(answer) == 0: return 
        self._db[hostname] = [x.split()[-1] for x in answer][0] # throw all except the first
        self._write_db()
        return self._db[hostname]
        
    def getip(self, hostname):
        if hostname not in self._db.keys():
            print "calling dig on %s" % hostname
            if not self.call_dig(hostname):
                return '127.0.0.1'
        return self._db[hostname]
            

if __name__ == '__main__':

    udps = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udps.bind(('',53))
    ipcache = IPCache()

    start = time.time()

    try:
        while 1:
            data, addr = udps.recvfrom(1024)
            p=DNSQuery(data)
            ip = ipcache.getip(p.domain)
            udps.sendto(p.response(ip), addr)
            print '%8.3f responded: %s -> %s' % (time.time() - start, p.domain, ip)
    except KeyboardInterrupt:
        print 'closing'
    udps.close()

